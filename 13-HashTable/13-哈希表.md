## 哈希表
    1. 哈希表基础
        <1> 首先，我们通过leetcode中一个关于hash表的问题引入hash表的相关内容。解决leetcode中387号问题（参考代码部分）

        <2> 什么是哈希表
            * 每一个字符都和一个索引相对应

            * 哈希函数：就是指将对应的数据表示为索引的操作过程（将"键"转换为"索引"）。如在解决上述问题中index = ch - 'a'

<img src="../img/13/img01.jpg " width=800px>

<img src="../img/13/img02.jpg " width=800px>

            * 时间换空间的算法思想

<img src="../img/13/img03.jpg " width=800px>

        <3> 哈希表是时间和空间之间的平衡。哈希函数的设计是很重要的。“键”通过哈希函数得到的“索引”分布越均匀越好（举例：对
            身份证而言，如果开辟18位数的空间，那么17位以内的空间都浪费，这就不均匀不合理）

    2. 哈希函数的设计
        *  一般的设计原则
            <1> 整形
                * 小范围的正整数直接使用

                * 小范围的负整数需要进行偏移。如：-100~100   --->   0~200

                * 大整数
                    通常情况进行取模。举例如下，观察发现会导致分布不均匀。那么我们就需要通过对一个素数进行取模来解决这一个
                    问题。（为什么？参考下列图片分析）

<img src="../img/13/img04.jpg " width=800px>

<img src="../img/13/img05.jpg " width=800px>

                * 在如何去一个素数时，我们可以参考下表

<img src="../img/13/img06.jpg " width=800px>


            <2> 浮点型

<img src="../img/13/img07.jpg " width=800px>

            <3> 字符串

<img src="../img/13/img08.jpg " width=800px>

<img src="../img/13/img09.jpg " width=800px>

<img src="../img/13/img10.jpg " width=800px>

            <4> 复合类型

<img src="../img/13/img11.jpg " width=800px>

        * 总结

<img src="../img/13/img12.jpg " width=800px>

    3. Java中的hashCode
        * 主要通过代码实现

    4. 哈希冲突的处理方式：链地址法 Separate Chaining

<img src="../img/13/img13.jpg " width=800px>
        
        <1> 如上图所示，当我们在存储数据时，如果数据k2与k3发生了冲突，那么就按照链表的方式存储两个数据，也就是说在数组中
            我们存储的不是一个具体数据而是treemap，如下图

<img src="../img/13/img14.jpg " width=800px>

    5. 实现哈希表（参考代码）

    6. 哈希表的动态空间处理与复杂度分析
        <1> 时间复杂度分析

<img src="../img/13/img15.jpg " width=800px>

        <2> 那么通过上图可以发现，HashTable的时间复杂度，并没有达到O(1)级别，那么就需要通过动态的空间处理来实现（这与
            我们在动态数组中扩容类似）
        
<img src="../img/13/img16.jpg " width=800px>

    7. 哈希表更复杂的动态空间处理方法
        <1> 经过resize操作后，哈希表的时间复杂度分析，如下图

<img src="../img/13/img17.jpg " width=800px>

        <2> 更多复杂的动态空间处理方法
            * 经过分析，我们发现，使用素数M作为容量，在扩容或缩容后就不再是素数，所以，我们需要使用以下的方式来解决这一
              问题。如图，使用下列的素数表中的素数来扩容（下列素数大致都是2倍的关系）

<img src="../img/13/img18.jpg " width=800px>

        <3> 哈希表通过树结构来实现提升了时间复杂度的同时，也破坏了树结构的顺序性

        <4> 通过分析，我们发现实现的哈希表是存在bug的：
            * bug：我们在实现哈希表时，key是不可比较的(没有继承Comparable接口)，而我们使用的TreeMap是可比较的，这就产
                   生了冲突

    8. 解决哈希冲突的其他方法
        <1> 开放地址法
            * 就是指在发生hash冲突之后，将后面要添加的元素存放在对应索引的下一个索引位置。如果多个冲突，那么就依次向后找
              这叫做开放地址法的线性探测。线性探测的缺点是容易导致更多的hash冲突。同时时间复杂度就月复杂。如下图

<img src="../img/13/img19.jpg " width=800px>

            * 由于线性探测的缺点，人们通过平方探测进行优化，平方探测就是指在发生冲突后向后1（1的平方）的位置找，如果被占用，
              则向后4（2的平方）找，依次类推。如图

<img src="../img/13/img20.jpg " width=800px>

            * 开放地址法的二次哈希就是指在遇到哈希冲突后，使用另外一个哈希函数计算对应的位置。如下图

            * 注意：开放地址法也会存满，所以需要resize扩容，我们通过负载率（表示占用地址占全部地址的百分比）来确定是否扩容

            * 对于开放地址法只要负载率合适，那么也能达到O(1)级别的时间复杂度

        <2> 其他方法
            * 再哈希法（ReHashing）：

            * Coalesed Hashing：综合了链地址法与开放地址法








 
