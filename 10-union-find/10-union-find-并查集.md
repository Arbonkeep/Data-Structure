# union find 并查集
    1. 什么是并查集
        * 功能：
            <1> 能够很好的解决网络中节点间的连接问题（这里的网络是个抽象的概念：用户之间形成的网络）

            <2> 应用于数学中的集合的实现

        * 连接问题与路径问题
            * 在解决路径问题的同时，我们也能够解决连接问题，但是利用解决路径问题的思路解决路径问题，多了一些不必要
              的操作，因为我们只需要知道是否连接，而不需要直到具体连接路径

        * 并查集对于一组数据而言，主要支持两个动作：
            * union(p, q)：将传入的两个数据以及所在的集合合并起来

            * isConnected()：查询两个数据是否属于同一个集合

    2. Quick Find
        * 对于isConnected而言，在数组中很好展示，假如数组中有2个集合存储的两种不同类型的数据，那么我们可以通过前半
          部分设置为集合1的数据，而后半部分存储集合2的数据（也可以偶数的索引对应为集合1的元素，奇数索引为集合2的元
          素）那么在判断两个数据之间是否为同一类数据（isConnected）就很好判断。

        * QuickFind下的Union
            * 分析：如下图所示，如果union(1,4)连接了起来，那么相应的与1和4同类的元素也都连接了起来。也就是说，在这
                    个数组中共有两种类型，那么如果1,4连接了，所有的都会连接

<img src="../img/10/img01.jpg " width=800px>

            * 缺点：unionElenments(p,q)的时间复杂度为O(n)级别
            
            * 优点：而isConnected的时间复杂度为O(1)级别的

    3. Quick Union
        * 这是实现并查集的第二种方式（相比与第一种方式，此方式的查询比较慢，而合并比较快）

        * 这种实现方式是将孩子节点指向父节点实现的树结构

<img src="../img/10/img02.jpg " width=800px>

    4. 基于size的优化
        * 由于在UnionFind2中的unionElements方法，没有对size的长度进行综合考虑，所以速度会较慢，我们可以通过对size
          的维护来有话我们实现的并查集

        * 将节点个数小的树的根节点指向节点个数多的树的根节点

    5. 基于rank的优化（rank指树的高度或深度）
        * 优化原理：记录每个节点上以当前节点为根的最大深度是多少，将深度比较低的那棵树向深度比较高的那棵树进行合并

        * 同样的，我们依然使用数组来进行实现，其中rank[i]代表节点为i的树的高度（深度）为多少

        * 在合并操作（UnionElements）中，当在两棵树高度不等的情况下由于是高度少的树向高度高的树进行合并，也就是说
          前者的高度必然不会大于后者的高度，那么我们就可以得出结论：不需要维护树的高度rank[i]。但是在两棵树高度一致
          的情况下，那么一棵树合并并到另外一棵树，树的高度就需要+1

    6. 路径压缩 Path Compression
        * 实现原理：就是让一颗比较高的树压缩成一颗比较低的树

        * 如下图所示：我们执行路径压缩操作只需要实现：parent[p] = parent[parent[p]]
                     也就是说将p节点的父节点设置成p节点的父节点的父节点

<img src="../img/10/img03.jpg " width=800px>

        * 路径压缩的最优情况：每一个查询的节点都指向了根节点（也就是使用递归方法实现）
            * 如下图

<img src="../img/10/img04.jpg " width=800px>

        * 注意：并查集的时间复杂度为O(log*n)级别，它比O(logn)要快，接近于O(1)级别

         