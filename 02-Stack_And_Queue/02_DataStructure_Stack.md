# 栈和队列
    1. 栈和栈的应用：撤销操作和系统栈
        * 概念：栈也是一种线性结构，是一种先进后出的数据结构（相当于手枪压子弹）
        * 特点：
            1. 相比于数组，栈对应的操作是数组的子集
            2. 栈只能从一端添加元素，也只能从一段获取元素，这一段被称为栈顶

        * undo(撤销)：相当于将加载进栈的东西给拿出来。
    
    2. 栈的实现
        1. 定义Stack<E>接口,有下列五个方法
            void push<E>:添加元素
            E pop()：取出元素
            E peek()：查看栈顶
            int getSize()
            boolean isEmpty()
        2. 定义实现接口的方法ArrayStack<E>
            重写接口方法
            重写toString方法
    3. 栈的应用
        * undo操作 编辑器
        * 系统调用栈 操作系统
        * 括号匹配 编译期
            代码实现：有效括号（括号需要匹配上相同的）的实现，利用栈这个数据结构来实现
                栈顶元素就是在嵌套层次中最近的需要匹配的关系元素

                <1> 通过java中的Stack类来实现
                <2> 创建一个栈
                <3> 将传入的字符串进行遍历获取每一个字符
                <4> 通过栈的特点对每一个字符进行判断
                        * 如果字符为左括号部分，那么我们就将字符添加进栈内存
                        * 否则进行下一步判断（如果栈为空，那么说明匹配失败，如果栈顶元素与压进栈的字符不匹配，那么就说明匹配失败）
                        * 直接将栈是否为空的结果进行返回。

            注意：* leekcode中修饰的方法不能够用private修饰，因为这样就不能调用自己实现的方法。
                  * leekcode中我们可以通过内部类的方式将自己的类提交给leekcode使用。

    4. 数组队列（Queue）
        * 概念
        
            队列也是一种线性结构，相对于数组，队列对应的操作是数组的子集
        * 特点
            队列数组是只能够从一端存储数据（队尾），从另一端获取数据（队首）的一种数据结构
            这是一种先进先出的数据结构(FIFO)

        * 栈的实现
            <1> 定义接口，实现下列方法
                void equeue(E)：向队列中添加一个元素，入队
                E dequeue()：取出一个元素，出队
                E getfront()：查看队首的元素
                int getSize()
                boolean isEmpty()
            <2> 定义实现类实现上述方法

            注意：在队列中，取出元素是从队首取出，添加元素是从队尾添加
        
    5. 循环队列
        *  目的：用于解决数组队列中取出一个元素方法（出队）中的时间复杂度为O(n)级别的问题（数组队列的局限性）
        *　概念：
            1. 上述问题是如何出现的？
                <1> 数组对列实现取出元素，从队首取出元素后需要将后边的所有元素向前移动。这也就是为什么时间复杂度为O(n)的原因。
                <2> 由于出队后，剩下的元素依然是队列，那么我们就需要实现保持这个队形（后面的元素不需要向前移动）
                <3> 基于<2>想法，我们需要用一个变量来记录队首和队尾，即front，tail，也就是说当继续取出元素时，我们只需要维护
                    队首的位置即可。这就是循环队列的实现方式
            
            2. 循环队列的原理
                假设队列的capacity是8，
                <1> 当front == tail时，就说明队列中没有元素。
                <2> 如果有元素入队，只需要维护队尾即可(tail++),入如果有元素出队，那么只需要维护front即可(front++)
                <3> 当元素添加到7索引的位置时，tail就不能继续向后移动了，但是队首有元素出队（前面空间可以存元素）
                    那么tail就需要向前移动到0索引，那么如何向前移动呢？通过[(最后一个索引 + 1) % capacity]实现
                <4> 如果此时有元素入队，那么就会存放在0索引（依次向后）那么如果元素存满了此刻就有达到了 front ==
                    tail的条件（队列不为空），因此我们需要解决这个问题
                <5> 通过 （tail + 1）% capacity == front 来表示队列存满（也就是说在队列中我们需要空出一个位置不存放元素），只要
                    达到这个条件，我们就需要扩容了 

                    注意：如何表示不是最后一个元素：(当前索引 + 1) % capacity ！= tail

        * 实现
            1. 实现queue接口
            2. 直接底层实现，不需要使用动态数组类
                <1> 定义成员成员变量 定义E数组，front，tail，size（size可以不定义实现）
                <2> 定义方法 有参构造，无参构造，获取capacity，获取size，isEmpty等
                    
                    * 入对enqueue
                        判断队列是否存满，维护tail，存满就扩容resize(2 * capacity) 
                    * 出队dequeue
                        判断队列是否为空，维护front，当size小于2/capacity时，需要进行缩容

                    * 定义查看队首元素是什么的方法getFront
                        判断是否为空，不为空返回队首元素即可
                    * resize方法
                        创建一个新的数组，然后遍历将元素存入新数组，将新数组的引用指向原来data数组
                    * toString方法

    6. 数组队列与循环队列的比较
        目的：比较数组队列与循环的的执行效率
        结论：数组队列的效率要比循环队列的执行效果差

    7. 线性数据结构总结
        * 分类
            * 动态数组
            * 栈
            * 队列
        * 总结
            底层都是依赖静态数组实现的，并且依靠resize来解决容量问题

        


    
                    

                    

                


























