# 二分搜索树（Binary Search Tree）
    1. 为什么使用树结构
        * 树结构存储数据十分高效
    
    2. 二叉树基础
        * 二叉树有唯一的根节点，二叉树中每个节点最多有两个树枝叉，每个节点只能有一个父节点
        * 二叉树也就有天然递归结构
            * 每个节点的左子树也是二叉树
            * 每个节点的右子树也是二叉树
        * 二分搜索树
            * 首先二分搜索树是一个二叉树
            * 其次二分搜索树的每个节点的值，大于其左子树的所有节点的值，小于其右子树的所有节点的值
            * 每一颗子树也是二分搜索树
            * 存储的元素必须具有可比较性
        
    3. 向二分搜索树中添加元素
        * 我们定义的二分搜索树不包含重复元素，那么实现包含重复元素呢？
            左子树小于等于节点，或者右子树大于等于节点即可
    
    4. 二分搜索树树中查询元素

    5. 二分搜索树的遍历（深度优先遍历）
        * 前序遍历：先访问节点，然后访问子树
            目的：将二分树中所有的元素都访问打印一遍
            注意：查找时，只需要向某一边比较查找，而遍历则需要两边的数据都进行访问
           
        
        * 中序遍历：先访问左子树，然后访问节点，最后访问右子树
            注意：中序遍历的结果就是我们在对元素大小进行排序后的结果
        
        * 后序遍历：先访问子树，然后访问节点
            应用：为二分搜索树内存释放
        
        * 如何快速查看到遍历的结果：
            * 在遍历时，总共需要访问3次节点（查看左边元素时为第一次，查看完后回到该节点为第二次，查看右边元素时为第三次）
            * 前序遍历：按照从左到右的顺序依次访问元素（查看第一次访问节点时的元素，输出，其余两次不用理会）
            * 中序遍历：查看第二次访问节点时的元素，输出，其余两次不用理会
            * 后序遍历：查看第三次访问节点时的元素，输出，其余两次不用理会

    6. 二分搜索树前序遍历非递归写法
        * 利用栈来实现
            由于后进先出的特点需要先将右子树压进栈  
        * 实现步骤
            1. 创建栈对象
            2. 将根节点压入栈
            3. 访问当前节点（获取栈顶元素，并遍历）
            4. 依次将二分搜索树的右子树和左子树压进栈
    
    7. 二分搜索树的层序遍历（广度优先遍历）
        * 利用队列数据结构来实现
            队列是先进先出，直接先将左子树的节点加入队列
        * 实现原理
            假设有三层
            首先将根节点加入队列，访问根节点，将左右子树依次加入队列，然后访问左子树节点，然后将左子树节点的左右子树加入
            队列，然后访问根节点下的右子树，将其左右子树依次加入队列，然后按队列顺序依次访问输出即可
        * 实现步骤
            1. 创建队列对象（queue为接口需要指定具体实现类）
            2. 将根节点添加进队列
            3. 访问当前节点（获取队列中的元素，并且遍历）
            4. 依次将二分搜索树的右子树和左子树加入队列

        * 可用于求最短路径

    8. 二分搜索树中删除元素
        二分搜索树中的最大值：就是在二分搜索树中最右边的那个节点
        二分搜索树中的最小值：就是在二分搜索树中最左边的那个节点

        * 利用递归实现寻找最小元素
        * 利用递归实现寻找最大元素

        * 删除最小元素
            1. 最小值为叶子节点（该节点后面没有节点了）：直接删除即可
            2. 最小值不是叶子节点（该节点有右子树）：将该节点删除，将右子树与这个二分搜索树连接起来

        * 删除最大元素
            1. 最大值为叶子节点（该节点后面没有节点了）：直接删除即可
            2. 最大值不是叶子节点（该节点有左子树）：将该节点删除，将左子树与这个二分搜索树连接起来
        
        * 删除任意元素
            假设node为删除节点
            1. 只有左子树的情况：直接将node的左子树的根节点指向node即可（直接return node.left）
            2. 只有右子树的情况：直接将node删除，将node的右子树的根节点指向node（直接return node.right）
            3. 两边都有子树的情况：
                需要找到右子树中最小值，将该最小值作为连接左右子树的节点

