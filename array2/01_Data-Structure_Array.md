# 数组
    介绍：可以使用leekcode网站来进行数据结构的练习

    1. 概述
        * 数组简单理解就是把数据码成一排进行存放
        
        * 索引：索引可以有语义，也可以没有语义
            如：一个数组中存放学生成绩，数组中的索引可以用来代表学生的学号（有语义），也可以直接当成数组的索引
                来使用。

        * 优点：快速查询 => 所以最好应用于有语义的情况。        
                但是并所有有语义的数组都适合用于数组。
                    如:用数组存储身份证号，身份证号并不适合用来当作数组的索引。

    2. 向数组中添加元素
        * 向数组末尾添加元素（前提:数组size < 数组capacity）
            <1> 在元素末尾添加元素，需要将size传入的，元素为size赋值
            <2> 添加元素后size的长度改变，size++
        * 向指定位置添加元素（前提:数组size < 数组capacity）
            <1> 首先依次将数组后面的元素向后移动，可以通过倒着遍历数组，将前一个元素的索引的值与后一个元素的索引的值交换实现
            <2> 当空出我们需要的位置时,将元素添加进去
            <3> 此时数组的长度发生改变，需要更新数组size++ 

        * 在数组的最开始的位置添加一个元素
            <1> 倒着遍历数组，并将元素向后移动一位
            <2> 为第一个元素赋值
            <3> 将size进行更新size++

    3. 如何在数组中查询元素
        <1> 为我们自定义的数组需要重写toString方法用于遍历查询我们得到的数组
        <2> 遍历数组，将数组中的每一个元素进行拼接
        <3> 利用StringBuilder方法对我们的遍历进行拼接字符串

    4. 数组中的包含，进行数组的搜索和删除
        * 定义数组中是否有指定的元素的方法（contains）
            <1> 对元素进行遍历
            <2> 查看元素中是否有指定的元素（调用equals方法实现）
            <3> 如果有我们就返回true，如果没有我们就返回false

        * 定义数组中如果有指定的元素，那么我们就返回他的索引的方法（查找数组中元素的索引）
            <1> 对元素进行遍历
            <2> 查看元素中是否有指定的元素
            <3> 如果有我们就返回元素的索引，如果没有我们就返回-1

        * 定义删除指定位置的索引的元素，并且返回该元素的方法
            <1> 将指定元素的索引传入，获取该元素(用于最后的返回)
            <2> 循环遍历，也就是说index之后的元素我们都需要将元素向前移动一个位置
            <3> 将最后的值返回

            注意：我们可以通过方法的复用定义删除第一个元素和最后一个元素的方法。

    5. 泛型的使用
        * 作用：让我们可以存储“任意数据”类型的数据
            注意：这里任意不能存储基本数据类型，但是能够存储基本数据类型的包装类

        * 问题：java数组中不能定义一个泛型类型的数组（如何解决呢）
            解决措施：我们可以创建一个Object类型的数组，然后将数组进行向下强转（为指定类型）
                        如：E[] data = ( E[] ) new Object[10];              //将Object数组强转为E类型数组

        * 注意：
            1. 当我们在修改元素的泛型时，只要是与我们指定的泛型有关的元素，或者返回值都需要修改，同时在进行if
                判断时，需要考虑==号与equals是否需要改变。  
            
            2. 在之前，定义删除元素的方法时，遍历时size指针指向了一个值（这个值并不会影响我们的实现效果），但是
                使用泛型后，内存中记录的是地址值引用，而我们不删除这个引用，会导致垃圾回收器不去清理它，所以我们
                可以将这个引用指定为null

    6. 动态数组
        * 实现原理：
            假设一个数组data的capacity只能存储4个元素，那么我们需要存储更多的元素，就需要通过新创建一个数组newData
            （capacity=8）来存储更多的元素，然后循环遍历将data数组中的元素添加到newData数组中，最后将data的引用指向
            newData的引用（原来的newData引用被释放）即可实现。

        * 所需实现的功能
            1. 实现动态增加数组容量，在我们添加元素时，capacity == size时，我们需要对数组进行扩容（2 * data.length）
            2. 实现动态减少数组容量，在我们删除元素时，capacity == 2 * size时，我们需要减少数组的容量（data.length / 2）

    7. 简单的时间复杂度分析
        1. 概念
            * 种类：O(1),O(n)，(n的2次方),O(lgn),O(nlogn)等
            * 注意：
                1. 在计算时间复杂度的计算的时候，我们是忽略常数进行计算的，也就是说O这个符号需要将常数忽略掉
                2. 并非O(n)的时间复杂度就一定会大于O（n的2次方），这是跟n的大小有关的。即并非前面的算法就会比后面的算法快。
                3. n越大，那么O(n)的算法效率越能显现出来
        
        2.对数组方法的实现的时间复杂度的分析
            * 添加方法，整体属于O（n）类型
                1. addLast方法属于O(1)类型
                2. add方法属于O（n）的类型
                 。。。
            * 删除操作也是一个O（n）类型
            * 修改操作是已知索引为O（1）级别，未知索引为O（n）级别
            * 查询操作一直索引为O（1）级别，未知索引为O（n）级别

    8. 均摊复杂度和防止复杂度的震荡
        * 就addLast方法出现resize方法的复杂度分析
            假设capacity为8,那么首先要实现8次O（1）级别的操作，然后进行扩容（resise）那么就再次需要进行8+1次操作（其中
            包括转移数据到另外一个数组，以及一次创建数组的操作），也就是说执行完整的方法执行需要17次操作。也就是说没进行
            addLast操作就需要进行2次基本操作。

            结论：假设capacity=n，那么n+1次addLast，触发resize，总共需要进行2n+1次基本操作，也就是说每次addLast操作
                进行2次基本操作，这样均摊计算时间复杂度就是O（1）级别的。
                注意：在这样的例子中（特点：出现resize的机会较小）均摊计算比计算醉话的情况更加有意义。

        * 复杂度震荡问题（也就是同时出现removeLast和addLast的操作）
            * 出现这个问题的原因：removeLast时，resize过于着急(eager).也就是说，在扩容后增加一个元素，又立刻将元素删除
                                这样就会导致扩容后立马又减少容量。这就会导致复杂度的震荡。
            * 解决方案：    
                    利用较Lazy的方式：当数组扩容后（扩容一倍），减少了一个元素时，我们不需要立刻缩容，而是等到减少的元素
                    到了扩容后数组容量的1/4时，我们再进行缩容（缩小到原来数组的1/2）。

































